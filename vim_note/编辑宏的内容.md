- #### 我们之前讲过, 在宏的结尾添加命令非常容易, 但是如果想删除宏的最后一条命令, 或者在宏的开头改点什么东西, 该怎么办呢 ? 本节将学习像文本一样编辑宏的内容
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 问题: 非标准格式  
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假设已经遵从 **录制工作单元** 的步骤, 将所有按键操作都保存至寄存器 **a** 了, 接下来, 要处理以下文件, 它与之前的文件相比, 在格式上略有差异

        ```txt
            1. One
            2. Two
            3. three
            4. four
        ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以看出 有些含已经使用了大写字母, 而 有些行还是用的小写字母, 我们在之前的宏中 使用 **~** 命令 切换光标所在的字母大小写, 而这一次, 用新命令 **vU** 替换 **~** 命令, 它会把光标所在处的字母变为大写 (:h v_U)
        
        ---

    - #### 将宏粘贴到文档中
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于录制宏的寄存器, 与用作复制, 粘贴 操作的寄存器相同, 因此 如果像修改寄存器 **a** 中的宏, 只需要将其 粘贴 到文档中, 就可与像编辑普通文本一样编辑它了
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先, 按 **G** 键 跳到文档末尾, 目的是将寄存器 **a** 中的内容粘贴到新的一行, 处理这种情况 最简单的方法是用 **:put** 命令

          ```vim
          :put a
          ```
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当然, 也可以直接使用 **: \$ put a ** 命令 一次把寄存器内容加到末尾
         
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为什么不使用 **"ap** 命令呢 ? 因为在本例上下文中, p 命令会把寄存器 **a** 的内容粘贴到当前行的光标后面, 而 **:put** 命令总是会把它们粘贴到当前行的下方, 无论寄存器保存的是面向行的还是面向字符的文本块
    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在就可与像编辑普通文本一样编辑宏了 如下表所示, 将 **~** 替换位 **vU**

        | 操作       | 缓冲区内容        |
        | :-:        | :--               |
        | start      | <u>0</u>f.r)w~j   |
        | f~         | 0f.r)w<u>~</u>j   |
        | svU < Esc> | aof.r)wv<u>U</u>j |
---
- #### 将宏的内容复制回寄存器
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们已经得到了一组命令序列, 它看上去正是我们像要的样子, 因此, 可与将其从文档复制会寄存器.
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最简单的方法就是运行 **"add(或者 :d a)**, 但这么做可能会在以后导致问题. dd 将执行面向行的删除操作, 因此, 寄存器会包含一个拖尾字符 **^J**

        ```vim
        :reg a
        << 0f.r)wvuj^J
        ```
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **^J** 表示一个换行符, 而且在大多数情况下, 该字符都无关紧要, 但是有时候这个拖尾字符可能会改变宏的意义. 为了保险起见, 用面向字符的复制操作把这些字符从文档复制会寄存器可会更安全.

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 依次运行命令 **0** 以及 **"ay$**, 把该行除了回车以为的每一个字符都删除下来. 再把宏的内容保存hi寄存器 **a** 之后, 就可与用 **dd** 删除这一行了. 尽管删除的内容将被保存到 **无名寄存器**, 但无名也不会用到它们.
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 做完以上这些步骤, 当前寄存器 **a**中保存着一个新的, 可改进的宏, 可将其用的开头的示例文本.

    操作表

    | 操作  | 缓冲区内容                                          |
    | :-:   | :--                                                 |
    | start | // last line of the file proper<br>0f.r)wv<u>U</u>j |
    | "ay$  | // last line of the file proper<br><u>0</u>f.r)wvUj |
    | dd    | <u>/</u>/ last line of the file prope               |

    ---

- ### 结论
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 能够将宏粘贴到文档, 进行编辑, 然后复制回寄存器中执行, 这样做的确方便, 但出于 **宏中的键盘编码** 罗列的诸多原因, 使用寄存器 必须特别谨慎, 如果执行将一条命令追加至宏的结尾, 使用 q{宏名称(大写)} 的步骤会更加简单.
 
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于 vim 的寄存器不过是一些保存文本串的容器, 也可以编写 vim 脚本来操作它们. 例如使用 **substitute()** 函数 (与 **:substitute** 命令不同, 参见 :h substitute()) 做上述操作的编辑

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们甚至可以单独写一行代码, 而不是录制宏 的方式, 直接写一个宏命令, 然后直接复制到寄存器中, 虽然这样做可能 可以避免 宏中的键盘编码问题, 但是确需要我们高度集中注意力.

        ```vim
        :let @a=substitute(@a,'\~','vU','g')
        ```
---

- #### 宏中的键盘编码
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 本例使用的是一个相对简单的寄存器, 但如果试着编辑一个很大的宏, 事情就会变得一团糟. 比如这个宏
        
    ```vim
    :reg a
    << --- Register ---
        "a  Omoul<80>kb<80>kbdule Rank^[j>GGoend^[
    ```
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意到奇怪的地方了吗? 首先, **^[** 出现了好多次, 不论是按 < Esc > 还是 < Crtl+[ >, vim 都用 **^[** 表示 **< Esc >** 键.
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更蹊跷的是代表退格键的 **<80>kb**, 分析下这组按键操作, 在刚开始录制这个宏时, 输入的是 "moul", 但当发现错误后, 又案例几次退格键, 随后又输入了单词余下的部分"dule"
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个动作没有效果, 如果回放这些按键操作, vim 将依次重新 错误和改正 的过程, 尽管结果是正确的, 但的确让急促七年的内容难以阅读, 而且编辑起来会更复杂
