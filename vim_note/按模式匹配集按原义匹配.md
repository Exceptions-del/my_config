-  在这一部分,将讨论查找, substitute 和 glob 命令, 但是线把目光集中在驱动它们的核心上,  即 'vim' 的搜索引擎 .
-  vim 的 正则表达式 可能和 我们习惯用的其他引擎有所不同, 我们将会看到, 最容易被混淆 的差异 可以被 very magic 模式开关轻松化解 . 
-  在 vim 的查找域 ( search field ) 中, 某些字符 默认 具有特殊含义,当只像要 按 原义 匹配一段文本时, 这一特点 将会导致问题复杂化 . 为此, 需要掌握如何使用 very nomagic 原义的开关, 一举屏蔽这些特殊含义 . 
-  我们将关注几个可以和在 vim 查找模式 中使用的特殊 **元字符**, 即 零宽度定界符 . 这些字符可以用于标记某个单词或某个查找匹配的边界 .
 
---

- #### 调整查找模式的大小写敏感性
    ##### 我们既可以 全局性 的调整 vim 查找功能的大小写敏感性, 也可以在每次查找时进行局部调整
    ---
    - 设置大小写敏感性:  
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果启用 'ignorecase' 设置, vim 的查找模式将不区分大小写
      
      ```vim
      :set ignorecase
      ```
    
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 正如在 <b>自动补全大小写敏感性</b> 中讨论的那样, 这个命令有副作用, 它会影响 vim 关键字自动补全的行为 .
      
    - 每次查找时设置大小写敏感性:  
         
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用 元字符 <b>\c</b> 或 <b>\C</b> 可以覆盖 vim 默认的大小写敏感性设置 . 小写字母 <b>\c</b> 会让查找模式忽略大小写, 而大写字母 <b>\C</b> 会强制区分大小写 . 使用了这两个元字符中的 一个, 'ignorecase' 的值会被这次查找忽略(这两个元字符可以出现在模式的任意位置, 只要使用了这两个元字符, 就会作用域整个模式)
    
    - 智能的大小写敏感性设置:  
    
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vim 提供了一项额外的设置, 用于最大限度地推测我们是想用大写还是小写 -- 'smartcase'选项, 该选项被启用后, 无论何时, 只要在查找模式中 输入 了大写字母, 'ignorecase' 设置就不再生效了 . <br>换句话说, 如果模式全是由小写字母组成的, 就会按照忽略 大小写的方式查找, 但是只要输入一个大写字母, 查找方式就会 变成 区分大小写了 . 
        
        ```vim
        :set smartcase
        ```
        
        查找模式大小写敏感性
        
    | 模式   | 'ignorecase' | 'smartcase' | 匹配        |
    | :----: | :-:          | :-:         | :-:         |
    | foo    | off          | -           | foo         |
    | foo    | on           | -           | foo Foo FOO |
    | foo    | on           | on          | foo Foo FOO |
    | foo    | on           | on          | Foo         |
    | foo    | on           | off         | foo Foo FOO |
    | \cfoo  | -            | -           | foo Foo F00 |
    | foo    | -            | -           | foo         |

- ##### 按正则表达式查找时, 使用 \v 模式开关
    #####  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  与 Prel 相比, vim 正则表达式的 语法风格更接近 POSIX . 但是使用 very magic 模式开关, 就可以让 vim 采用我们更为熟悉的正则表达式语法了.
    ---
    - 假设我要构建一个正则表达式, 匹配下面 css 片段中的每一组颜色代码 . 
      
      ```css
      body      { color: #3c3c3c; }
      a         { color: #0000EE; }
      strong    { color: #000; }
      ```
        - #### 使用 magic 模式来构建正则表达式来匹配这些代码  
        
        ```vim
        /#\([0-9a-fA-F])\{6}|[0-9a-fA-F]\{3}\)
        ```
    
        #####  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以发现, 我们使用了太多的 反斜杠 '\', 本例用到了 3类 <b>括号</b>,<b>方括号</b> 默认没有特殊含义, 因此不用转义, <b>圆括号</b> 和 <b>花括号</b> 会按照原义匹配字符, 所以需要转义, 不过 <b>花括号</b> 只有 <b>开括号</b> 需要转义, 而 <b>闭括号</b> 不用, 因为 vim 会推测我们的意图,  <b>圆括号</b> 开闭括号都必须转义.
        ---
        - #### 使用 very magic 搜索模式 匹配这些代码
        
        ```vim
        /\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})
        ```
        
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以利用 <b>\v</b> 模式开关来统一所以特殊符号的 规则, 该元字符将激活 <b>very magic</b> 模式, 即假定 <b>_</b>, 大小写字母 以及数值 0~9 之外的字符都具有特殊含义 (参见:h \v )  
        
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>\v</b> 模式开关 使得 vim 的正则表达式引擎更像是 Perl, Python 或者 Ruby 所为, 尽管如此, <b>它们之间仍然存在差异</b> . 关于这点需要注意 . 但与规定哪个必须转义, <b>\v</b> 模式开关更容易记忆 
        
        ##### 由于现在 起始位置的 <b>\v</b>,位于它后面的所有字符都具有特殊含义 . 这样一来 那些反斜杠字符就可以去除了, 可读性是不是更强了?
        ---
        - #### 用十六进制字符类进一步优化模式  
           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我们可以进一步优化这个模式, 在拼写时, 用字符类 <b>\x</b> 来代替完整字符集 [0-9a-fA-F] (参见 :h /character-classes) 以下模式等同于前面的正则表达式
          
          ```vim
          /\v#(\x{6}|\x{3})
          ```
        ---
    
- ### 结论
    
下表逐项对比了每一个正则表达式  
    
| 模式 | 说明 |
|------|------|
| ```#\([0-9a-fA-F]\{6}\ | [0-9a-fA-F]\{3}\)``` | ```使用 magic 搜索模式时,必须转义 '(',  ')', '|' 以及 '{' 字符,赋予它们特殊的含义``` |
| ```\v#([0-9a-fA-F]{6}  | [0-9a-fA-F{3}])```   | ```使用 \v 搜索模式开关后 '(', ')', '\a', '|' 以及 '{' 字符会表现出特殊含义```             |
| ```\v#(\x{6}           | \x{3})```            | ```使用 \x 字符类代替 [0-9a-fA-F] 可以进一步精简表达式```                               

---    
    
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  最后说明一点 : 字符 <b>#</b> 没有特殊含义, 可以按原义匹配, <b>very magic</b> 搜索模式是把除了 <b>_</b>, 字母和数值以外的字符都当作具有特殊含义的字符, 这是该规则的一个特例.   
 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对于这个问题, vim 的解释是 任何为具有特殊含义的字符都被 "保留以被未来扩展时使用" (参见 :h/\\). 换句话说, 尽管<b>#</b> 目前不具有特殊含义, 但不意味着 将来的版本也会这样.
