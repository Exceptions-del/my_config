- #### 对于多行范围内的重复性改动, 可以先录制一个宏, 然后在每一行上回放, 这会极大减轻我们的工作量, 该功能可用串行或并行的方式实现.

 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们将对以下的文本进行转换
```txt
1. one
2. two
3. three
4. four
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 转换为

```txt
1) One
2) Two
3) Three
4) Four
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 虽然这个任务看起来比较简单, 但是由他引出的几个问题却很值得玩味

- #### 录制工作单元(下划线表示光标所在位置)

    | 操作 | 内容                                             |                  说明                   |
    |------|--------------------------------------------------|:---------------------------------------:|
    | qa   | 1. <u>o</u>ne<br>2. two<br>3. three<br>4. four   |               开始录制宏                |
    | 0f.  | 1<u>.</u> one<br>2. two<br>3. three<br>4.four    |   跳转到行首, 并使用f 命令跳转到 '.'   |
    | r)   | 1<u>)</u> one<br>2. two<br>3. three<br>4. four   |            将 '.'替换为 ')'             |
    | w~   | 1) <u>O</u>ne<br>2. two<br>3. three<br>4. four   | 跳转到下个单词的词首, 并转换它的大小写 |
    | j    | 1) One<br>2. <u>t</u>wo<br>3. three<br>4. four   |              移动到下一行               |
    | q    | 1) One<br>2. <u>t</u>wo<br>3. three<br>4. four   |               结束录制宏                |

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 命令将光标置于行首(空格前面, 如果要放在空格后面使用 '^' 或 '|' 命令), 从而规范光标的位置, 意味着下一条动作总是从相同的位置开始执行, 重复性更强, 也许你会任务使用 **f.** 命令有些浪费, 与 **l** 命令相同, 为什么非得要用两次按键呢?   

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为这正是为了能够重复, 本例中行号正好只是从 1 排到了 4 假如编号变为 2 位数 使用 **0l** 在 前9行 会把光标移动到每行的第二个字符上 正好是一个个句号, 但从 第10行 开始 这条命令没到达目标就会终止, 而 **f.** 对所有文本都适用 即使超过百位也没问题

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另外使用 **f.** 命令会增加一种安全捕获机制, 如果当前行没有找到 字符 '.' 时, 会提示一个错误, 宏将中止执行, 请记住这种用法

---

- #### 以串行的方式执行宏

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以用 **@a** 来执行刚刚录制好的宏, 我们可以调用3次 **@a** 来执行 3次宏命令 但是 **3@a** 会更快, 但是这在这种情况下会出现问题

    ```txt
    1. one
    2. two
    // break up the monotony 
    3. three
    4. four
    ```
    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 回放刚刚录制的宏, 我们发现宏在执行到 **第三行**时停了下来, 没错就是那行注释. **f.** 命令没有在这行发现字符 '.' 于是宏被中止了, 安全机制拦截住了我们, 这也是个好事情, 因为如果该宏成功的在这行执行了, 也就意味着它做了我们可能更不想要的修改


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 执行 5@a 后的结果

```txt
1) One
2) Two
// break up the montony
3. three
4. four
```

---

- #### 以并行的方式执行宏
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 之前学习过 在选择模式下运行 <b>.</b> 命令, 在这里也能使用相同的技术

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>:normal @a</b> 命令指示 vim 在高亮选区的每一行上执行这个宏, 就像串行运行那样, 宏在前两次成功执行了, 单在第3行被中止了, 但它并没有停在那里, 而是继续完成了任务, 因为执行 **5@a** 命令是, 是以串行的方式运行的, 当 第3次迭代被中段时, 列队中剩余的命令将被清除. 而这次, 我们把着5次迭代并行执行, 由于宏与宏直接调用相互独立, 因此, 即使第 3 次迭代是啊比了, 也不会影响其他迭代过程


|      操作       | 内容                                            |               说明                |
|:---------------:|-------------------------------------------------|:---------------------------------:|
|       qa        | 1. o<u>n</u>e<br>2. two<br>3. three<br>4. four  |             开始录制              |
|     0f.r)w~     | 1) <u>O</u>ne<br>2. two<br>3. three<br>4. four  |             宏的内容              |
|        q        | 1) <u>O</u>ne                                   |             完成录制              |
|       jVG       | 1) One<br><u>2. two<br>3. three<br>4. four</u>  | 向下移动一行, 同时高亮到最后一行 |
| :'<, '>normal @a | 1) One<br>2) Two<br>3) Three<br>4) Four         |     对高亮的每一行执行宏命令      |

---

#### 决策:串行还是并行
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 串行或者并行, 那种方式更好呢? 答案(永远)是看情况
 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以并行的方式在多处执行宏更为健壮, 在本例中, 采用这种方法更好, 但如果宏在执行时遇到一处错误, 而我们正想利用这些警告更正错误时, 采用 串行, 多次的方式执行宏可以更容易定位出问题的所在
