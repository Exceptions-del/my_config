&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vim提供了不只一种方式用于重复之前所做的修改, 我们已经学过了. 命令, 用它来重复小的修改确实有效, 但想重复更大规模的改动时, vim 宏就排上用场了, 可以用宏把任意数目的按键操作录制到寄存器, 用于之后回收

---

 - 宏很适合一系列相似的行, 段落, 甚至文件, 进行重复性修改. 
   
 - 在一组目标上执行宏有两种方式---以串行方式回放或者以并行的方式多次运行
 
 - 在录制, 难免会出错, 不过用不着推翻重来, 因为可以很方便地在宏原有的结尾附加新的命令, 如果要对宏进行较大的修改, 甚至可以将宏粘贴到一个文档里, 对该命令进行编辑, 然后再将其复制回寄存器
 
 - 有时需要往文本里插入连续的数字, 使用表达式寄存器 和 脚本结合使用, 可以实现该功能
 
 - 就像黑白棋游戏一样, 学会 vim 的宏只需要一分钟, 但是却要穷其一生才能精通. 不过从新手到高手, 每个人都能从该功能中获益匪浅, 因为它让我们的工作更任意自动化. 
    
---
  
  - ####  宏的录制与读取  
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 宏运行把一段修改序列录制下来, 用于之后的回放.

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 许多重复性的任务都会涉及多处修改. 如果想要自动完成这些修改, 可以录制一个宏, 然后执行它

    ---

	- ##### 把命令序列录制为宏  
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `q` 键既是 "**录制**" 的按钮, 也是 "**停止**" 的按钮.为了记录按键操作, 一开始需要按 `q{小写字母}` 从而指定一个保存宏的寄存器,当状态栏中出现 "**记录中**" 时,表示录制已经开始, 此后我们执行的每一条命令都会被宏捕获, 直到再次按下 `q` 键停止
    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查看 宏 寄存器 `:*reg {宏名称}` 将显示刚刚录制的命令 唯一可能不同的符号是 `^[`, 它代表 `<Esc>` 键, 对它的解释见宏中的键盘编码
 
     
    - ##### 通过执行宏来回放命令序列
     
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以用 `@{resiger}` 的命令来执行寄存器的内容, 在使用过一次 `@{resiger}` 之后 可以直接使用 `@@` 命令来重复执行这个宏, 该操作类似 `.` 命令
    
    - ##### 以串行的方式执行宏
     
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 录制宏的过程很像为机器人编写 "**完成一道工序**" 的程序, 作为最后一步, 我们命令机器人移动传送带并抓主下一个零件. 按照这种方式, 只需要一个机器人就能在相似的零件上执行一系列重复有序的工作了
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 采用这种方法的后果之一是, 如果机器人中途遇到特殊情况, 必须发出警报并终止操作. 即使传送带上仍有零件需要装配, 也只能放弃.
        
    - ##### 以并行的方式执行宏
     
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以并行的方式执行宏, 就好像完全不用传送带, 取而代之的是部署一组机器人. 我们同样要控制它们完成刚才简单的任务. 这一次, 我们安排了一个机器人只干一个工作. 如果某个机器人能完成交给它的任务固然很号, 但如果失败了, 也不会影响其他机器人.

        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 无论使用哪一种技术,从本质上讲, vim 一直会顺序的执行宏, "**并行**"一词意在类比并联电路的 "**健壮性**"", 并不是说 vim 真的会并发地执行多处修改


        |   按键   |         功能         |
        | ------ | ------------------ |
        |    `q`     |  录制宏 / 停止录制   |
        | `@+{宏}` |      执行宏命令      |
        |    `@@`    | 重复执行上一个宏命令 |

---

  - #### 规范光标的位置, 直达目标以及终止  
  
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在执行宏的过程中, 有时会产生意外的结果, 但是如果能遵从一些最佳的应用方式, 就能取地更好的一致性

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当我们执行一个宏时, vim 会机械地重复这个打包在一起的按键操作序列, 如果我们不小心的话, 在回放宏时的结果会偏离我们的预期. 但也可以录制更为灵活的宏, 针对每一种情况, 它都能应对自如

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 黄金法则: 在录制一个宏时, 要确保每条命令都可以被重复执行 

    ---

    -  ##### 规范光标位置
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一旦开始录制宏, 首先要问自己几个问题, 我在哪儿? 我从哪里来? 要到哪里区? 在你想做任何事之前, 要确保你的光标位置已经就位, 只有这样下一条命令才会做你想做的事情, 去你想去的位置. 
         
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这意味着应该把光标移动到下一处查找匹配项( `n` ) 或者当前行的行首( `0` ), 又或者是当前文件的行首( `gg` ). 如果每次总是从确定的位置开始执行的话, 那么命中正确目标会变得更容易

    - ##### 用可重复的动作命令直达目标
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vim 有一组丰富的动作命令集, 通过它们, 可以直达文本的各各角落. 
         
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 千万别为了让光标达到目标而一直按 `l`, 请记住, vim 会机械的执行你的按键操作. `w`, `e`, `b`, 和 `ge`, 与面向字符的 `h` 和 `l` 相比更具有 "**灵活性**"
         
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 推荐使用 "**查找命令**" 定位, 或者使用 "**文本对象**". 总之尽量使你的宏兼具 "**灵活性**" 与 "**可重复性**" 

    - ##### 当动作命令失败时, 宏将停止执行
     
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vim 的命令可能会执行失败. 例如, 如果光标位于文件的首行, 运行 `k` 命令将什么也不会发生, 若光标位于文件末行, 按下 `j` 也会出现类似的情况, 出现上述情况时 vim 会发出 "**哔**" 的一声, 提升我们动作失败了, 当然也可以设置 `visualbell` 关闭提示音
         
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果宏执行动作命令失败了, vim 将中止执行宏的其余命令 这是一项**功能** 而不是漏洞, 可以用动作命令进行简单测试来判断是否应该在当前上下文中继续执行
         
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以使用 `[number]@{register}` 的方法来执行宏, 并且可以不必顾忌次数, 因为没有下一个匹配项时, 宏将中止退出, 执行 100@a, 甚至是 1000@a 的结果都是一样的

---

  
  - #### 加次数回放宏  
  
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于重复次数不多的工作, 点范式 是一种高效的编辑策略, 但它不能指定执行次数, 为了克服该限制, 可以录制一个廉价的, 一次性 的宏, 然后再加次数就进行回放

    ---

    比如这段代码
 
    ```javascript
    var foo = "method("+argument+", "+argument+")"; 
    ```
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我想把它变成这个样子
    
    ```javascript
    var foo = "method(" + argument + "," + argument + ")"; 
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以使用点`.`命令, 意味着完成这个任务只需要简单的重复几次 `;.` 命令, 可是如果遇到更大范围的情况, 应该怎么做?

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当然我们依然可以使用 `;.` 命令 但是需要调用非常多次 `;.` 命令才能完成任务, 工作量也不小, 人们很自然的想到 `{number};.` 应该能完成这个任务, 但是实际上它并不管用, 因为 vim 会先执行n次 `;` 命令 再执行一次 `.` 命令, 而我们的目的是要运行 `n` 次 `;.` 命令

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过录制一个简单的宏可以模拟 n 次 `;.`  即 `qq;.q`
  
  
    | 按键                    | 说明                                                                    |
    |-------------------------|-------------------------------------------------------------------------|
    | {start}                 | `x` = "("+a+","+b+","+c+","+d+","+e+")";                                |
    | `f+`                    | x = "("`+`a+","+b+","+c+","+d+","+e+")";                                |
    | `s<space>+<space><ESC>` | x = "(" +<code></code>a+","+b+","+c+","+d+","+e+")";                    |
    | `qq;.q`                 | x = "(" + a +<code></code>","+b+","+c+","+d+","+e+")";                  |
    | `22@q`                  | x = "(" + a + "," + b + "," + c + "," + d + "," + e +<code></code> ")"; |

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们只需要用大于或等于最大次数(跳转最多的次数)的宏, 该宏就可以完成任务 最后一次执行将会被终止(如果是用查找命令跳转的话)
   
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意: 不是每个宏都能用估算次数的方法调用, 本例之所以可以这样是因为该宏本身隐含了一种内置的安全捕获机制(如果 "**当前行**" 找不到下一个 `+` 号, 则 `;` 命令会失败, 宏将终止)

  
  - #### 在连续的文本行上重复修改  
  
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于多行范围内的重复性改动, 可以先录制一个宏, 然后在每一行上回放, 这会极大减轻我们的工作量, 该功能可用串行或并行的方式实现.

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们将对以下的文本进行转换
    
    ```txt
    1. one 
    2. two 
    3. three 
    4. four 
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 转换为

    ```txt
    1) One 
    2) Two 
    3) Three 
    4) Four 
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 虽然这个任务看起来比较简单, 但是由他引出的几个问题却很值得玩味

    -  ##### 录制工作单元(下划线表示光标所在位置)  

        | 操作 | 内容                                         |                  说明                  |
        |------|----------------------------------------------|:--------------------------------------:|
        | `qa`   | 1. `o`ne<br>2. two<br>3. three<br>4. four    |               开始录制宏               |
        | `0f.`  | 1`.` one<br>2. two<br>3. three<br>4.four     |   跳转到行首, 并使用f 命令跳转到 '.'   |
        | `r)`   | 1`)` one<br>2. two<br>3. three<br>4. four    |            将 '.'替换为 ')'            |
        | `w~`   | 1) `O`ne<br>2. two<br>3. three<br>4. four    | 跳转到下个单词的词首, 并转换它的大小写 |
        | `j`    | 1) One<br>2. `t`wo<br>3. three<br>4. four   |              移动到下一行              |
        | `q`    | 1) One<br>2. `t`wowo<br>3. three<br>4. four |               结束录制宏               |


    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `0` 命令将光标置于行首(空格前面, 如果要放在空格后面使用 `^` 或 `|` 命令), 从而规范光标的位置, 意味着下一条动作总是从相同的位置开始执行, 重复性更强, 也许你会任务使用 `f.` 命令有些浪费, 与 `l` 命令相同, 为什么非得要用两次按键呢?   

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为这正是为了能够重复, 本例中行号正好只是从 1 排到了 4 假如编号变为 2 位数 使用 `0l` 在 前9行 会把光标移动到每行的第二个字符上正好是一个句号, 但从第10行开始这条命令没到达目标就会终止, 而 `f.` 对所有文本都适用, 即使超过百行也没问题

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另外使用 `f.` 命令会增加一种安全捕获机制, 如果当前行没有找到字符 `.` 时, 会提示一个错误, 宏将中止执行, 请记住这种用法

    - ##### 以串行的方式执行宏

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以用 `@a` 来执行刚刚录制好的宏, 我们可以调用3次 `@a` 来执行 3次宏命令 但是 `3@a` 会更快, 但是这在这种情况下会出现问题

    ```txt
    1. one
    2. two
    // break up the monotony 
    3. three
    4. four
    ```
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 回放刚刚录制的宏, 我们发现宏在执行到 **第三行** 时停了下来, 没错就是那行注释`f.` 命令没有在这行发现字符 `.` 于是宏被中止了, 安全机制拦截住了我们, 这也是个好事情, 因为如果该宏成功的在这行执行了, 也就意味着它做了我们可能更不想要的修改

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 执行 `5@a` 后的结果

    ```txt
    1) One
    2) Two
    // break up the montony
    3. three
    4. four
    ```

    - ##### 以并行的方式执行宏
     
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 之前学习过 在选择模式下运行 `.` 命令, 在这里也能使用相同的技术

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `:normal @a` 命令指示 vim 在高亮选区的每一行上执行这个宏, 就像串行运行那样, 宏在前两次成功执行了, 单在第3行被中止了, 但它并没有停在那里, 而是继续完成了任.  
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为执行 `5@a` 命令是, 是以串行的方式运行的, 当 第3次迭代被中段时, 列队中剩余的命令将被清除. 而这次, 我们把着5次迭代并行执行, 由于宏与宏直接调用相互独立, 因此, 即使第 3 次迭代是啊比了, 也不会影响其他迭代过程


    |      操作       | 内容                                            |               说明                |
    |---------------|-------------------------------------------------|---------------------------------|
    |       `qa`        | 1. o`n`e<br>2. two<br>3. three<br>4. four  |             开始录制              |
    |     `0f.r)w~`     | 1) `O`ne<br>2. two<br>3. three<br>4. four  |             宏的内容              |
    |        `q`        | 1) `O`ne                                   |             完成录制              |
    |       `jVG`       | 1) One<br>`2. two<br>3. three<br>4. four`  | 向下移动一行, 同时高亮到最后一行 |
    | `:'<, '>normal @a` | 1) One<br>2) Two<br>3) Three<br>4) Four         |     对高亮的每一行执行宏命令      |


    - ##### 决策: 串行还是并行
     
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 串行或者并行, 那种方式更好呢? 答案(永远)是看情况
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以并行的方式在多处执行宏更为健壮, 在本例中, 采用这种方法更好, 但如果宏在执行时遇到一处错误, 而我们正想利用这些警告更正错误时, 采用 串行, 多次的方式执行宏可以更容易定位出问题的所在

  - #### 给宏追加命令
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 有时候, 我们在录制宏的过程中会漏掉某个至关重要的步骤, 在这种情况下, 没有必要从头开始录制所有步骤, 而是可以在现有宏的结尾附加额外的命令.
     
    使用以下命令即可查看寄存器中的内容:  
    
    ```vim
    :reg {register} 
    ```
     
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 给宏追加命令十分简单, 只需按下 `q{大写字母}`, 是的只需要将宏名称换成大写就可以进行追加宏命令, 再次使用 `:reg [register]` 会发现我们将指令追加到寄存器原有的内容之后

    - 结论:  

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这种方法可能可以把我们从 '**被迫重新录制宏**' 的困境中解救出来, 但是这种方法只能在宏的结尾添加命令, 如果想在宏的开头或者中间的某个位置添加内容, 它就无能为力了
  
  - #### 在一组文件中执行宏  
 	
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 到目前为止, 我们所关注的任务都是在相同的文件中用宏重复操作, 但是也可以跨文件回放宏. 这次仍然考虑如何以并行或者串行的方式执行宏

	---
    
	有这么两个函数
   
	```python
	#...注释 
	def well(name): 
		print(f'它的名字是{name}') 
		
	def how(pagl): 
		print(f'它会使用{pagl}') 
		
	```

	把这2个 函数 封装为一个类, 最终看起来是这样的
   
	```python
	#...注释 
	class Play: 

		def well(self, name): 
			print(f'它的名字是{name}') 
		
		
		def how(self, pagl): 
			print(f'它会使用{pagl}') 
			   
	```
    
    在执行宏之前先加载以下的配置
   
	```vim
	:set nocompatible 
	filetype plugin indent on 
	set hidden 
	if has('autocmd') 
		autocmd FileType ruby setlocal ts=2 sts=2 sw=2 expandtab 
	endif 
	```
    
	打开目标文件
   
	```vim
	:cd 文件路径 
	:args *.py 
	```
	这里使用不带参数的 `:args` 命令, 就可以显示参数列表的内容. 这样使用 `:first`, `:last`, `:prev`, `:next` 就能遍历整个文件列表

	录制宏

    | 动作                        | 说明                                                                               |
    |-----------------------------|------------------------------------------------------------------------------------|
    | `:first`                    | 跳转到参数列表中的第一个文件                                                       |
    | `qa`                        | 开始录制宏                                                                         |
    | `gg/def<CR>`                | 跳到文件开头, 由于每个文件开头有注释, <br>我们需要用查找命令找到我们要的 "**def**" |
    | `O<C-o> Oclass Play: <Esc>` | 在def 的上方打2个空行, 方便添加 "**class**"                                        |
    | `j>G`                       | 将class下面的行都缩一个`<tab>`                                                     |
    | `/):<CR>biself,jnb.<Esc>`   | 将每个函数添加上 "***self,***" <br>(这一步最好再单独另外录制一个宏来执行)          |
    | `q`                         | 结束录制                                                                           |

	- ##### 以并行的方式运行宏
        
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果正在使用编辑器, 正在使用编辑器跟着做, 请先别急着运行 `:w` 保存文件, 因为这样只会保存当前窗口所在的缓冲区   
	   
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `:argdo` 命令会运行对参数列表内的所有缓冲区执行一条Ex命令, 但是现在如果执行 `:argdo normal @a` 命令的话将会出现副作用  
		
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  仔细想想便会发现, 运行 `:argdo noraml @a ` 将对所有参数列表的缓冲区执行刚录制的宏, 当然也包括哪个在录制宏修改的文件, 因此第一个缓冲区的内容会被封装两次
		
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为了避免这种情况, 将执行 `:edit!` 将放弃针对第一个缓冲区的所有修改(见:h edit!) 如果已经修改后已经保存至文件, 那么执行 `:edit!` 将起不到任何作用, 这种情况下只能执行 `u` 命令恢复到原样了
		
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在恢复修改后 可以在参数列表中的所有缓冲区内执行宏了
		
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 尽管该技术需要进行一些设置, 但它用一条命令就能为我们做很多工作.
		 
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 需要注意的是执行宏命令一定要注意是重复跳转是否会被中止, 如果不会中止而使用过多次数的宏, 则会出现我们不想要的结果
		
	 
	- ##### 以串行的方式运行宏
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 宏通常被用在单一的缓冲区执行单一的工作单元, 如果想使其在多个缓冲区内运行, 可以在宏的最后附加一个步骤 :  跳转到下一个缓冲区
	 
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 虽然可以执行 `3@a` 让宏在缓冲区列表余下的每个文件得以执行, 但是次数没必要那么精确, 因为, 宏一旦执行到参数列表的最后一个缓冲区, `:next` 命令将会失败, 宏便会中止退出, 所以, 与其指定一个精确的数值, 不如保证数字足够大就可以

	 
	- ##### 保存所有文件的改动
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们已经改了多个文件, 但是一个也没有保存, 运行 `:argdo write` 即可保存缓冲区列表的所有文件, 但是如果 使用 `:wall`  命令, 会更快(该命令会保存缓冲区列表内的所有文件, 因此它不完全等于 `:argdo write` 参见 h: wa)  
        
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另一条有用的命令是 `:wnext` 它等同于先运行 `:write` 再执行 `:next`, 如果想用串行的方式, 在参数列表的多个文件上执行宏, 可能用这条命令会更好.

	- ##### 结论
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假设宏执行到位与参数的第三个缓冲区时, 由于某种原因失败了, 如果此使用并行的方式, 则执行失败的缓冲区会受到影响 ; 不过如果以串行, 带次数的方式执行宏, 它将会中止执行, 而参数列表余下的文件将不会被修改  
        
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  这一次我们在一组文件上运行, 所以我们无法做到 '只需要看一眼就可以对所有情况了如指掌' 但是如果以串行的方式还好 一旦失败, 便会在出错的位置停下来但如果以并行的方式运行宏, 一但失败, 就不得不浏览整个参数列表.

		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  以并行的方式运行宏, 虽然可能会更快的完成工作, 不过当有错误发生时, 会遗漏许多有用的信息

  
  - #### 用迭代求值的方式给列表编号  
   
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  如果宏在每次执行中都能插入一个可变的数值, 这将会很有用处, 这次我们将学习到一种新的技术, 它会在录制宏时 使某个数字递增, 这样一来, 就可以在 连续的文本上 插入数字 1~5.

    ---
     
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实例代码
        
    ```txt
    partridge in pear tree
    turle doves
    Fernch hens
    calling birds
    golden rings
    ```
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们想最终把它转换成这个样子

    ```txt
    1) partridge in pear tree
    2) turle doves
    3) Fernch hens
    4) calling birds
    5) golden rings
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们之前学习过了`<C-a>` (增加光标下的数字) 和 `<C-x>` (减少光标下的数字) 的方法, 也可以使用表达式寄存器, 为了完成这次任务将使用 "**表达式寄存器**" 并结合一点 Vim 脚本.

    ---

    - ##### 基本的 Vim 脚本
        
        使用 `let` 关键字 可以创建一个遍历, 可以使用 `:echo` 命令查看变量的当前值:
        
        ```vim
        :let i=0
        :echo i
        << 0
        ```
        累加 i 的值
        
        ```vim
        :let i += 1
        :echo i
        << 1
        ```
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果我们只想查看 变量 的值, `:echo` 就足够了, 但实际上, 我们只想要在文档中插入这个值, 因此需要用到表达式寄存器 ( `<C-r>=i<CR>` ), 就可以插入变量 `i` 的值.

        录制宏
    
        | 操作                        | 内容                                    | 说明                      |
        |-----------------------------|-----------------------------------------|---------------------------|
        | `:let i=1`                  | 1) `p`artridge in a pear tree           | 创建变量 `i`              |
        | `qa`                        | 1) `p`artridge in a pear tree           | 开始录制宏                |
        | `I<Crtl+r>=i<CR><ESC>` | 1)<code></code>partridge in a pear tree | 在行首插入变量 `i` 的内容 |
        | `:let i += 1`               | 1)<code></code>partridge in a pear tree | 让变量 `i` 加 1           |
        | `q`                         | 1)<code></code>partridge in a pear tree | 结束录制                  |

        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在录制宏之前, 把 变量 **i** 赋值为 1, 在宏的录制过程中, 利用表达式寄存器 插入 i 的值, 而在停止录制之前, 在出发该变量进行累加, 现在就应该是 2 了

        运行宏

        | 操作              | 缓冲区内容                                                                                                         |
        | ---               | ---                                                                                                                |
        | start             | 1)<code></code>partridge in pear tree<br>turle doves<br>Fernch hens<br>calling birds<br>golden rings               |
        | `jVG`             | 1) partridge in pear tree<br>`turle doves`<br>`Fernch hens`<br>`calling birds`<br>`golden rings`                   |
        | `:'<,'>normal @a` | 1)` `partridge in pear tree<br>2) turle doves<br>3) Fernch hens<br>4) calling birds<br>5)<code></code>golden rings |

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如表所示, 可以在余下的文本上回放这个宏.  
       
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `:normal @a` 命令将指示 vim 在高亮选区的每一行上执行这个宏, `i `的初始值是 1, 但它在每次宏执行完成后都会递增. 最终, 每行都以连续的数字开头了  
       
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 也可以通过 复制, 粘贴, 以及 `<Crt+a>` 命令来完成同样的工作, 作为练习可以自己试一试.  
  
  - #### 编辑宏的内容  
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们之前讲过, 在宏的结尾添加命令非常容易, 但是如果想删除宏的最后一条命令, 或者在宏的开头改点什么东西, 该怎么办呢 ? 本节将学习像文本一样编辑宏的内容  
    
    ##### 问题: 非标准格式:  
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假设已经遵从 "**录制工作单元**" 的步骤, 将所有按键操作都保存至寄存器 `a` 了, 接下来, 要处理以下文件, 它与之前的文件相比, 在格式上略有差异

    ```txt
    1. One
    2. Two
    3. three
    4. four
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以看出 有些含已经使用了大写字母, 而 有些行还是用的小写字母, 我们在之前的宏中 使用 `~` 命令 切换光标所在的字母大小写, 而这一次, 用新命令 `vU` 替换 `~` 命令, 它会把光标所在处的字母变为大写 (:h v_U)
        
    - ##### 将宏粘贴到文档中
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于录制宏的寄存器, 与用作复制, 粘贴 操作的寄存器相同, 因此 如果像修改寄存器 `a` 中的宏, 只需要将其粘贴到文档中, 就可与像编辑普通文本一样编辑它了
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先, 按 `G` 键 跳到文档末尾, 目的是将寄存器 `a` 中的内容粘贴到新的一行, 处理这种情况 最简单的方法是用 `:put` 命令

      ```vim
      :put a
      ```
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当然, 也可以直接使用 `:$ put a`  命令 一次把寄存器内容加到末尾
         
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为什么不使用 `"ap` 命令呢 ? 因为在本例上下文中, `p` 命令会把寄存器 `a` 的内容粘贴到当前行的光标后面, 而 `:put` 命令总是会把它们粘贴到当前行的下方, 无论寄存器保存的是面向行的还是面向字符的文本块

        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在就可与像编辑普通文本一样编辑宏了 如下表所示, 将 `~` 替换位 `vU`

        | 操作       | 缓冲区内容        |
        | :-:        | :--               |
        | start      | `0`f.r)w~j   |
        | f~         | 0f.r)w`~`j   |
        | svU < Esc> | aof.r)wv`U`j |
    
    - ##### 将宏的内容复制回寄存器
 
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们已经得到了一组命令序列, 它看上去正是我们像要的样子, 因此, 可与将其从文档复制会寄存器.
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最简单的方法就是运行 `"add`(或者 `:d a`), 但这么做可能会在以后导致问题. `dd` 将执行面向行的删除操作, 因此, 寄存器会包含一个拖尾字符 `^J`

        ```vim
        :reg a
        << 0f.r)wvuj^J
        ```
     
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `^J` 表示一个换行符, 而且在大多数情况下, 该字符都无关紧要, 但是有时候这个拖尾字符可能会改变宏的意义. 为了保险起见, 用面向字符的复制操作把这些字符从文档复制会寄存器可会更安全.

        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 依次运行命令 `0` 以及 `"ay$`, 把该行除了回车以为的每一个字符都删除下来. 再把宏的内容保存到寄存器 `a` 之后, 就可与用 `dd` 删除这一行了. 尽管删除的内容将被保存到 "**无名寄存器**", 但再也不会用到它们了.
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 做完以上这些步骤, 当前寄存器 `a` 中保存着一个新的, 可改进的宏, 可将其用的开头的示例文本.

        | 操作  | 缓冲区内容                                       |
        |-------|--------------------------------------------------|
        | start | // last line of the file proper<br>0f.r)wv`U`j |
        | `"ay$`  | // last line of the file proper<br>`0`f.r)wvUj |
        | `dd`    | `/`/ last line of the file prope               |

    - ##### 结论
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 能够将宏粘贴到文档, 进行编辑, 然后复制回寄存器中执行, 这样做的确方便, 但出于 "**宏中的键盘编码**" 罗列的诸多原因, 使用寄存器 必须特别谨慎, 如果执行将一条命令追加至宏的结尾, 使用 `q{register}` 的步骤会更加简单.
     
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于 vim 的寄存器不过是一些保存文本串的容器, 也可以编写 vim 脚本来操作它们. 例如使用 `substitute()` 函数 (与 `:substitute` 命令不同, 参见 :h substitute()) 做上述操作的编辑

        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们甚至可以单独写一行代码, 而不是录制宏 的方式, 直接写一个宏命令, 然后直接复制到寄存器中, 虽然这样做可能 可以避免 宏中的键盘编码问题, 但是确需要我们高度集中注意力.

        ```vim
        :let @a=substitute(@a,'\~','vU','g')
        ```

    - ##### 宏中的键盘编码
    
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 本例使用的是一个相对简单的寄存器, 但如果试着编辑一个很大的宏, 事情就会变得一团糟. 比如这个宏
            
        ```vim
        :reg a
        << --- Register ---
            "a  Omoul<80>kb<80>kbdule Rank^[j>GGoend^[
        ```
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注意到奇怪的地方了吗? 首先, `^[` 出现了好多次, 不论是按 `<Esc>` 还是 `<Crtl+[>`, vim 都用 `^[` 表示 `<Esc>` 键.
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 更蹊跷的是代表退格键的 `<80>kb`, 分析下这组按键操作, 在刚开始录制这个宏时, 输入的是 "**moul**", 但当发现错误后, 又案例几次退格键, 随后又输入了单词余下的部分 "**dule**"
        
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个动作没有效果, 如果回放这些按键操作, vim 将依次重新 错误和改正 的过程, 尽管结果是正确的, 但的确让寄存器的内容难以阅读, 而且编辑起来会更复杂


