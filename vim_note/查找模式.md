- ### 按模式匹配集按原义匹配

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在这一部分,将讨论查找, substitute 和 glob 命令, 但是线把目光集中在驱动它们的核心上,  即 'vim' 的搜索引擎 .
    
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vim 的 正则表达式 可能和 我们习惯用的其他引擎有所不同, 我们将会看到, 最容易被混淆 的差异 可以被 very magic 模式开关轻松化解 . 
 
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在 vim 的查找域 ( search field ) 中, 某些字符 默认 具有特殊含义,当只像要 按 原义 匹配一段文本时, 这一特点 将会导致问题复杂化 . 为此, 需要掌握如何使用 `very nomagic` 原义的开关, 一举屏蔽这些特殊含义 . 
    
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们将关注几个可以和在 vim 查找模式 中使用的特殊 **元字符**, 即 零宽度定界符 . 这些字符可以用于标记某个单词或某个查找匹配的边界 .
 
---

- #### 调整查找模式的大小写敏感性
	
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们既可以 全局性 的调整 vim 查找功能的大小写敏感性, 也可以在每次查找时进行局部调整
 
    - ##### 设置大小写敏感性:  
     
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果启用 `ignorecase` 设置, vim 的查找模式将不区分大小写

    ```vim
    :set ignorecase
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 正如在 <b>"自动补全大小写敏感性"</b> 中讨论的那样, 这个命令有副作用, 它会影响 vim 关键字自动补全的行为 .

    - ##### 每次查找时设置大小写敏感性:  
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用 元字符 `\c` 或 `\C` 可以覆盖 vim 默认的大小写敏感性设置 . 小写字母 `\c` 会让查找模式忽略大小写, 而大写字母 `\C` 会强制区分大小写 . 使用了这两个元字符中的 一个, `ignorecase` 的值会被这次查找忽略(这两个元字符可以出现在模式的任意位置, 只要使用了这两个元字符, 就会作用域整个模式)

    - ##### 智能的大小写敏感性设置:  

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vim 提供了一项额外的设置, 用于最大限度地推测我们是想用大写还是小写 -- `smartcase`选项, 该选项被启用后, 无论何时, 只要在查找模式中 输入 了大写字母, `ignorecase` 设置就不再生效了.  
     
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 换句话说, 如果模式全是由小写字母组成的, 就会按照忽略 大小写的方式查找, 但是只要输入一个大写字母, 查找方式就会 变成 区分大小写了 . 
    
    ```vim
    :set smartcase
    ```
    
    下表展示了查找模式大小写敏感性
    
    | 模式   | `ignorecase` | `smartcase` | 匹配        |
    | :----: | :-:          | :-:         | :-:         |
    | foo    | off          | -           | foo         |
    | foo    | on           | -           | foo Foo FOO |
    | foo    | on           | on          | foo Foo FOO |
    | foo    | on           | on          | Foo         |
    | foo    | on           | off         | foo Foo FOO |
    | \cfoo  | -            | -           | foo Foo F00 |
    | foo    | -            | -           | foo         |

    - ##### 按正则表达式查找时, 使用 `\v` 模式开关
     
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  与 Prel 相比, vim 正则表达式的 语法风格更接近 POSIX . 但是使用 `very magic` 模式开关, 就可以让 vim 采用我们更为熟悉的正则表达式语法了.
	
	假设我要构建一个正则表达式, 匹配下面 css 片段中的每一组颜色代码 . 
	
	```css
	body      { color: #3c3c3c; }
	a         { color: #0000EE; }
	strong    { color: #000; }
	```
 
	使用 magic 模式来构建正则表达式来匹配这些代码  
	
	```vim
	/#\([0-9a-fA-F])\{6}|[0-9a-fA-F]\{3}\)
	```
	
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以发现, 我们使用了太多的 `\`, 本例用到了 3类 <b>括号</b>. `[]` 默认没有特殊含义, 因此不用转义, `()` 和 `{}` 会按照原义匹配字符, 所以需要转义, 不过 `{}` 只有  `{` 需要转义, 而 `}` 不用, 因为 vim 会推测我们的意图,  `()`则开闭括号都必须转义.
	
	---
 
	- ##### 使用 very magic 搜索模式 匹配这些代码
	
	```vim
	/\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})
	```
	
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以利用 `\v` 模式开关来统一所以特殊符号的 规则, 该元字符将激活 `very magic` 模式, 即假定 `_`, `a-zA-Z` 以及数值 `0~9` 之外的字符都具有特殊含义 (参见:h \v )  
	
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `\v` 模式开关 使得 vim 的正则表达式引擎更像是 Perl, Python 或者 Ruby 所为, 尽管如此, <b>它们之间仍然存在差异</b> . 关于这点需要注意 . 但与规定哪个必须转义, `\v` 模式开关更容易记忆 
	
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于现在 起始位置的 `\v`,位于它后面的所有字符都具有特殊含义 . 这样一来 那些反斜杠字符就可以去除了, 可读性是不是更强了?
	
	- ##### 用十六进制字符类进一步优化模式  
	
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我们可以进一步优化这个模式, 在拼写时, 用字符类 `\x` 来代替完整字符集 [0-9a-fA-F] (参见 :h /character-classes) 以下模式等同于前面的正则表达式
	
	```vim
	/\v#(\x{6}|\x{3})
	```
	
	- ##### 结论
	
	下表逐项对比了每一个正则表达式  
	
	| 模式 | 说明 |
	|------|------|
	| ```#\([0-9a-fA-F]\{6}\ | [0-9a-fA-F]\{3}\)``` | 使用 magic 搜索模式时,必须转义 `(`,  `)`, `|` 以及 `{` 字符,赋予它们特殊的含义 |
	| ```\v#([0-9a-fA-F]{6}  | [0-9a-fA-F{3}])```   | 使用 `\v` 搜索模式开关后 `(`, `)`, `\a`, `|` 以及 `{` 字符会表现出特殊含义             |
	| ```\v#(\x{6}           | \x{3})```            | 使用 \x 字符类代替 [0-9a-fA-F] 可以进一步精简表达式                               

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  最后说明一点 : 字符 `#` 没有特殊含义, 可以按原义匹配, `very magic` 搜索模式是把除了 `_`, `字母 `和 `数值` 以外的字符都当作具有特殊含义的字符, 这是该规则的一个特例.   
	 
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  对于这个问题, vim 的解释是 任何为具有特殊含义的字符都被 "保留以被未来扩展时使用" (参见 :h/\\). 换句话说, 尽管 `#` 目前不具有特殊含义, 但不意味着 将来的版本也会这样.
 
- ### 按原义查找时使用原义开关
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在正则表达式中使用的特殊字符, 在按模式查找时用起来很顺手, 但是如果想要按照原义进行查找时, 就需要转义, 它们就变成了阻碍, 使用 `very nomagic` 原义开关可以消除附加在 `.` 、`*` 以及 `?` 等大多数字符上的特殊含义  

    ---

    举个例子, 我们看下这段文本

    ```txt
    The N key searches backward...
    ...the \v pattern swithc (a.k.a very magic search)...
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  假设我们想要通过查找 <b>a.k.a</b>(also known as) 的方式将光标移动到该处, 针对这种情况, 第一反应是输入下面这条查找命令. 

    ```vim
    /a.k.a.
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  但按下回车时, 会发现次模式匹配的内容比我们预想的要多, 因为符号 `.` 有特殊含义, 它会匹配任意字符, 而单词 <b>"backward"</b> 正好会匹配到该模式  

    下表展示了查找的结果

    | 按键             | 缓冲区内容                                                                                     |
    |------------------|------------------------------------------------------------------------------------------------|
    | start            | <u>T</u>he N key searches backward...<br>...the \v pattern swithc (a.k.a very magic search)... |
    | /a.k.a< CR >     | The N key searches b`ackwar`d...<br>...the \v pattern swithc (`a.k.a` very magic search)...    |
    | /a\.k\.a\.< CR > | The N key searches backward...<br>...the \v pattern swithc (`a.k.a` very magic search)...      |
    | /\Va.k.a.< CR >  | The N key searches backward...<br>...the \v pattern swithc (`a.k.a` very magic search)...     |

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我们在本例中遇到的问题还不算太大, 因为只需要按一次 `n` 键, 就可以跳到下一处匹配 -- 真正的目标. 但在某些时候, 某个匹配被误判为正确, 可能会有 潜在风险. 试想一下, 如果我们没有意识到查找模式太宽泛了, 就接着运行 `substitute` 命令  例如:

    ``` 
    :s//also known as/g 
    ```

    若将 `substitute` 命令的查找区域留空, Vim 将使用上一次查找模式, 这将会导致某些意想不到的错误发生.

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我们可以用转义的方法消除 `.` 字符的特殊含义, 以下模式不会匹配单词 <b>"backward"</b> 中的一部分, 但仍然会匹配 <b>"a.k.a"</b>

    ```vim
    /a\.k\.a\.
    ```
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  或者可以使用 原义开关 `\V` 激活 `very nomagic` 搜索模式

    ```vim
    /\Va.k.a.
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `\V` 会使得其后的模式种只有 `\` 有特殊意义, 虽然这样过于简化了, 但却符合本例的目的 

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在 `very nomagic` 搜索模式下创建正则表达式也不是不可能, 不过很别扭, 因为必须为每个符号转义, 作为通用法则, 如果想按正则表达式查找 就用模式开关 `\v`, 而如果想按原义查找文本时 就使用 原义开关 `\V`

    - #### `\m` 与 `\M` 模式  

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于 vim 的模式来说, 除了 `\v` 与 `\V` 的语法外, 还有两种更为古老的语法, vim 默认使用 magic 搜索模式, nomagic 模式则用于模拟 vi 的行为, 可以通过使用 `\m` 和 `\M` 开关来分别使用这两种模式
         
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \M 作为 nomagic 搜索模式的开关, 其功能类似于 \V 原义开关, 不同的是, 有一些字符会自动具有特殊含义, 即符号 `^`(匹配开头) 和 `$`(匹配结尾).
            
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; magic 搜索模式会自动为某些额外的符号赋予特殊含义, 如 `.` 、`*` 以及 `[]`  

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; magic 搜索模式的设计初衷是为了更容易的构造简单的 正则表达式, 但却没能为如 `+` `?` `()` `{}` 等符号赋予特殊含义, 这些符号还必须经过转义后才有特殊含义
            
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; magic 搜索模式 希望让构造正则表达式变得更容易, 但是却半途而废, 导致 某些字符需要转义的规则定制的很混乱, 难以记忆. `\v` 模式查找开关正好弥补了这一点, 除了 `_` `数字` 和 `字母`外, 为所有符号都赋予了特殊含义 这样既好记, 又恰好和 Perl 正则表达式的规则保存一致

---

- ### 使用圆括号捕获分组

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  当指定一个模式时, 可以捕获其分组, 并在其他地方引用它们, 此方法于 `subtitute` 命令组合起来非常好用, 但它也可以用于定义某一类模式, 这类模式的特点是 重复包含某个单词

    ---

    来看下这一段文本 

    ```txt
    I love Paris in the
    the springtime.
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  你能指出其中的语法错误吗 ? 由于我们的大脑耍了一个小把戏, 我们会惊讶的发现很难指出问题所在, 但是如果把句子写出来, 出错的地方一下子就出来了  

    ```txt
    I love Paris in the the springtime.
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当换行符把两个重复的单词分隔开后, 我们的大脑往往 会忽略重复的那个词, 这就是所谓的 <b>"词法幻觉"</b>.

    ---

    这有一个专门用来匹配重复单词的正则表达式.

    ```vim
    /\v<(\w+)\_s+\1>
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在使用这个查找模式, 你会发现 `the the` 作为一处查找模式被匹配高亮起来, 现在再试着将两行文本连接起来(使用 `vipJ` 命令) 你会发现此模式仍然匹配,更棒的是, 这个不是不仅匹配 `the the`, 而且对所有成对出现的重复单词都有效 .

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在我们将这个正则表达式拆开来看, 看看它是怎么工作的.

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  我们之所以能两次匹配相同的单词, 关键就在于 `()` 和 `\1` 的组合使用 . 任何圆括号内部的匹配文本都会自动保存到一个临时仓库, 可以用 `\1` 引用这段被捕获的文本, 如果模式中包含不止了一组圆括号, 则可以使用 `\1`, `\2`,`\3` 直到 `\9`, 引用被每一对 `()` 捕获的内容 . 除此之外 元字符 `\0` 永远会引用整个匹配 .

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  这个用于匹配 <b>"词法幻觉"</b> 的正则表达式还包含了许多其他诀窍, 首先我们, 我们看到使用了 `\v` 模式开关 激活了 `very magic` 搜索模式, 另外 `<` 和`>` 两符号将用于匹配单词的边界. 最后, 元字符 `\_s` 会匹配空白符或换行符.

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在查找模式中使用 `()` 匹配的场景不太多, 比如 xml 或者 html 中标签的开闭对, 此外在 `:substitute` 命令的替换域中可以使用 捕获的分组

    - ##### 使用圆括号, 但不捕获其内容 

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  有时只想使用圆括号的分组内容, 但并不关系捕获的匹配, 比如可以用以下模式来匹配名字  

    ```vim
    /\v(And|D)rew Neil
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这次使用圆括号 的 目的在于 匹配 <b>"Andrew"</b> 或者 <b>"Drew"</b>, 但可能并不像捕获位于括号内部的 <b>"And"</b> 或 <b>"D"</b> 可以在圆括号前面加上 `%`, 指示 vim 不用将括号内部的内容赋值给寄存器 `\1`, 就像这样  

    ```vim
    /\v%(And|D)rew Neil
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  运行结果与之前有区别吗? 当然, 速度比原来快了一点, 只是你可能察觉不到 . 但如果你发现自己用到了多组圆括号, 这种方法就非常有用了. 比如, 这次我们像把所有的名和姓替换为姓和名,可以这样做  

    ```vim
    /\v(%(And|D)rew) (Neil)
    :%s//\2, \1/g
    ```

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  该查找模式会把 <b>"Andrew</b>" 或者 <b>"Drew"</b> 赋值给寄存器 `\1` 而把 <b>"Neil"</b> 赋值给寄存器 `\2` 如果没有对第二组括号使用 `%()`, 会得到无用的文本片段,从而扰乱替换域.

---

- ### 边界
 
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  在定义模式时, 如果能指定单词从哪里开始到哪里结束, 将会非常有用, vim 的单词定界符 可以帮助我们做到这一点.

    ---
    - #### 单词边界
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  有些单词, 尤其是短词, 经常出现在 其他单词内部, 比如 <b>"the"</b> 就会在 <b>"these"</b>, <b>"they"</b>, <b>"their"</b> 等单词中出现 . 因此, 如果在下面这段文本中执行 `/the<CR>` 进行查找的话, 会发现匹配的内容比我们预想的要多

    ---
    
    `the` problem with `the`se new recruits is that  
    `the`y don't keep `the`ir boots clean.
    
    ---

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  如果我们只是像要匹配 `the` 这个完整的单词, 而不是其他的 组成部分, 可以使用 单词定界符 . 在 `very magic` 模式下, 用 `<` 和`>` 符号表示单词定界符,因此, 如果将查找命令改为 `/\v<the><CR>` 文中就只会出现一处匹配了

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  这些就是所谓的零宽度元字符, 它们本身不匹配任何字符, 仅表示单词与围绕此单词的空白字符(或标点符号)的边界 .

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以将字符类 `\w`, `\W` 与匹配定界符 `\zs` `\ze` 组合在一起来模拟 `<` 与 `>` . `\w` 匹配单词类字符, 包括字母, 数字 以及符号 `_`, `\W` 则用来匹配除了 `\w`所匹配字符以外的字符

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将这些命令合而为一, 可以用 `\W\ze\w` 模拟元字符 `<`, 而用 `\w\ze\W` 表示元字符 `>`

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在 `very magic` 模式下, `<` 和`>` 字符可直接解析为 单词定界符, 而在 `magic`, `nomagic` 以及 `very magic` 搜索模式下, 必须将它们转义, 因此想要在 vim 文档中查阅这些选项得在前面加上转义字符 `\`

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 即使我们还没有养成使用单词定界符构造查找模式的习惯, 但每当使用 `*` 或者 `#` 命令 时就会间接用到它们, 这两条命令 分别用与正向或反向查找光标下的单词, 假设刚刚用过这两条命令中的一个, 再看看查找历史 (`/<UP>`) 时就会发现, 上次的查找模式被单词定界符围在中间. 

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `g*` 和 `g#` 这两种变体将执行同样的查找, 但不会使用单词定界符.


    - #### 界定匹配的边界

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  有时候, 可能像指定一个范围比较广的模式, 但只对匹配结果的一部分感兴趣, vim 中的元字符 `\zs` 和 `\ze` 可以帮我们处理这种情况 .  

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 直到现在, 我们还一直假设查找模式域它们实际产生的匹配是完全一致的 . 现在我们需要把它剥离为两个独立概念 . 

    定义:   

        - 模式: 是指在查找域输入的正则表达式  

        - 匹配: 是指在文档中被高亮显示的部分(假设以及启用 'hlsearch' 选项)


    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个匹配的边界通常对应一个模式的起始与结尾, 但可以用元字符 `\zs` 和 `\ze` 对匹配进行裁剪, 使其成为这个完整模式的一个子集元字符 `\zs` 标志着一个单词的开始, 元字符 `\ze` 则标志着单词的结束 . 当两者结合时, 可以定义一个特殊的模式,它们可以让我们定义一个模式匹配一个范围较大的文本范围, 然后缩减匹配范围 . 
     
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与单词定界符类似, `\zs` 和 `\ze` 均为零宽度元字符.
     
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 举一个栗子, 如果查找 `/Practical Vim<CR>` 文档中所有出现 <b>"Practical Vim"</b>的地方都会被高亮起来, 一旦查找模式改为 `/Practical \zsVim<CR>` 则只有单词 <b>"Vim"</b> 会被高亮, 而单词 <b>"Practical"</b> 会被排除到匹配外, 但它仍然是模式的一部分. 

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这样一来,只要 紧跟着单词 <b>"Practical"</b> 的 <b>"Vim"</b> 才会被高亮,其他前面不是 <b>"Practical"</b> 的 <b>"Vim"</b> 则不会被匹配, 这与 通过  `/vim<CR>` 命令进行查找的结果有很大不同  

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 还有另外一个栗子, 这次同时使用 `\zs` 和 `\ze` 对匹配的开始和结尾 进行微调
     
     
    | 按键                   | 缓冲区内容                                   |
    |------------------------|----------------------------------------------|
    | {start}                | `M`artch "quoted words"- - -not quote marks. |
    | `/\v"[^"]+"<CR>`       | Martch `"quoted words"`- - -not quote marks. |
    | `/\v"\zs[^"]+\ze"<CR>` | Martch `"quoted words"`- - -not quote marks. |

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个模式用到了一个常见的正则表达式 `[^"]+`,该模式使用了两个引号作为起始和结尾的标记, 然后排除引号之外的一个或多个字符, 在最后一行最为压轴出场的模式种, 在开引号加入了元字符 `\zs` 在比引号之前加入了元字符 `\ze` . 这样一来,引号本省被排除于匹配之外, 只剩下引用的内容被高亮起来 .(ps: 尽管引号被排除在匹配之外, 但它们仍然是你是中的关键部分)

---

- ### 转义

    &#160;&#160;&#160;&#160;&#160;`\V` 原义开关使得按原义查找文本变得更容易, 因为 `.` 、 `+` 和 `*` 的特殊含义被屏蔽掉了. 但还有一些字符, 其特殊含义无法被屏蔽. 

    ---

    - #### 正向查找时要转义 `/` 字符 

    以下摘录一段 Markdown 文档 

    ```Markdown
    Search items: [http://vimdoc.net/search?q=/\\] [s]
    ...

    [s]: http://vimdoc.net/search?q=/\\  
    ```

    &#160;&#160;&#160;&#160;&#160;假设想找到所有出现过的 URL `http://vim-doc.net/search?q=/\\` 的地方. 不必手动输入这些内容, 只需要复制到某个寄存器中, 然后再粘贴到查找域即可. 由于想精确地匹配这段文本, 因此要使用 `\V` 原义开关 .

    &#160;&#160;&#160;&#160;&#160;只要光标位于方括号之中, 就可以用 `"uyi[` 命令 将此 URL 复制到寄存器 u 中, 然后输入 `/\V<C-r>u<CR>` 即可将此寄存器内容填充至查找域了 . 最终的查找提示符类似于这样 .

    ---
    Search items : [`http:`//vimdoc.net/search?q=/\\] [s]  
    ...  
    [s]: `http:`//vimdoc.net/search?q=/\\

    ---

    &#160;&#160;&#160;&#160;&#160; 这是怎么一回事, 当我们把完整的 URL 粘贴到查找域后, Vim 却把首次出现的符号 `/` 解析成了 <b>"查找结束符"</b> .因此,所有位于首个正斜杠后的内容都被忽略掉了, 所以查找字符串只剩下了 <b>"http:"</b> 了.  

    &#160;&#160;&#160;&#160;&#160; 进行正向查找时, 必须转义符号 `/`, 而且无论执行的是 `very magic` 查找模式还是 `very nomagic` 查找模式都需要转义. 修正下之前的查找命令, 为每个 `/` 加上反斜杆前缀. 

    ```vim
    /\Vhttp:\/\/vimdoc.net\/search?q=\/\\
    ```

    &#160;&#160;&#160;&#160;&#160; 这次的查找结果与我们预估的更为接近了 .

    ```Markdown
    Search items : [`http://vimdoc.net/search?q=/\`\] [s]  
    ...  
    [s]: http://vimdoc.net/search?q=/\\
    ```

    &#160;&#160;&#160;&#160;&#160;但是还不够完美, 因为少了最后一个反斜杠. 我们很快将揭晓其中的奥秘, 但是首先考虑下反向查找.

    ---

    ### 反向查找时要转义 `?` 号

    &#160;&#160;&#160;&#160;&#160;执行反引号差找时, 符号 `?` 会被当作查找域的结束符. 这意味着 不必转义符号 `/`, 但是要对符号 `?` 进行转义 .

    &#160;&#160;&#160;&#160;&#160;现在我们不使用任何转义内容查找刚刚从寄存器 `u` 中复制而来的 URL 进行反向查找 :

    ```vim
    ⇒ ?http://vimdoc.net/search?q=/\\
    ```

    ---

    Search items: [`http://vimdoc.net/search`?q=/\\] [s]  
    ...  
    [s]: `http://vimdoc.net/search`?q=/\\

    ---

    &#160;&#160;&#160;&#160;&#160;我们发现,  Vim 将匹配字符串 "http://vimdoc.net/search". 这个结果比未转义的正向查找号多了, 但仍然未匹配完整的URL. 如果将 <b>?</b> 加上反斜杠, 会获得更好的效果. 

    ```
    ⇐ ?http://vimdoc.net/search\?=/\
    ```

    &#160;&#160;&#160;&#160;&#160;以下是新的匹配结果

    ---

    Search items : [`http://vimdoc.net/search?q=/\\`] [s]  
    ...  
    [s]: `http://vimdoc.net/search?q=/\\`

    ---

    - #### 每次查找都要转义符号 `\`

    &#160;&#160;&#160;&#160;&#160;在查找域中, 还有一个字符需要转义, 即反斜杆. 通常情况下, 一个 `\` 的出现意味着, 紧挨着它后面的字符会得到某种特殊对待. 如果将其加倍, 变为 `\\` 之后, 前者会消除后者的特殊含义, 实际上让 Vim查找一个 `\`  

    &#160;&#160;&#160;&#160;&#160;所以在正向查找中要查找两个连续的 `\`, 我们必须在查找域中为每一个 `\` 前面各加一个 `\`, 在正向查找中, 我们最终的模式是这样的:  

    ```vim
    /\Vhttp:\/\/vimdoc.net\/search?q\/\\\\
    ```

    &#160;&#160;&#160;&#160;&#160;这样就完成了匹配整个URL.

    &#160;&#160;&#160;&#160;&#160;无论采用正向还是反向查找模式, `\` 永远需要转义


    - #### 用编程的方式转义字符 

    &#160;&#160;&#160;&#160;&#160;用手动方式转义字符既耗时费力, 又容易出错. 幸运的是, Vim 提供了一个库函数, 帮助我们完成这项任务, 即 `escape({string},{chars})`, `{chars}` 参数将指定哪些字符需要用反斜杠转义, 如果要进行正向查找时, 可以用 `escape(@u,'\/')` 它会为每个 `/` 加上反斜杠前缀, 但如果进行的是反向查找就需要用 `escape(@u,'?\')`.  

    &#160;&#160;&#160;&#160;&#160;首先, 要确保查找的URL仍然在寄存器 u 中, 然后, 输入 `/` 或者 `?`调出查找提示符, 二者均能正常工作. 最后, 要依次输入原义开关 `\V` 和插入寄存器中的内容 `<C-r>=`. 在完成以上操作后, vim 就会从查找提示符的状态切换到表达式寄存器提示符的状态了, 现在输入命令:  

    ```
    =escape(@u,getcmdtype().'\')
    ```

    &#160;&#160;&#160;&#160;&#160;在按下 `<CR>` 后,  `escape()` 函数将被执行, 其返回值将会被插入查找域, 如果在进行正向查找, getcmd() 函数至少简单地恢复符号 `/`, 而在反向查找时, 该函数会返回符号 `?`. 

    &#160;&#160;&#160;&#160;&#160;在 vim 脚本中, 操作符用来连接字符串, 因此, 在正向查找时, `getcmd().'\'` 将产生 `/\`, 而在反向查找中会得到 `?\` .最终结果表明, 无论那种查找反数, 表达式都将对寄存器 `u` 中的所有内容进行转义, 因此查找工作顺利结束 .

    &#160;&#160;&#160;&#160;&#160;切换至表达式寄存器的状态以及手动调用 `escape()` 函数, 仍然会涉及到很多输入, 如果再多用一点 Vim 脚本, 操作便可以实现自动化, 使人们感到方便. 

    ---

    ### 查找域结束符

    &#160;&#160;&#160;&#160;&#160;你可能会感觉奇怪, 为什么查找域会把某个字符视为结束符呢? 它为什么不把所有位于查找提示符之后的内容都纳入查找匹配呢 ? 答案是如果在查找域结束符之后附加某些标志位, 可以和调整 vim 查找模式的行为. 例如: 如果运行命令 `/vim/e<CR>`, 光标将会移动到每个匹配的结尾, 而非起始.

    &#160;&#160;&#160;&#160;&#160;还有一种输入的方式,让我们不必担心查找结束符的牵绊, 但它只能适用于 <b>Gvim</b>, 即使用 `:promptfind` 命令, 该命令调出一个带有 <b>"查找"</b> 标签的图形对话框, 可以在这里输入 `/` 和 `?` 无需转义, 遗憾的是, 字符 `\` 以及 换行符依然会引发问题.

