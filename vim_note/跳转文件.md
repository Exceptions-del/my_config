- #### 跳转缓冲区命令

    | 动作     | 作用                         |
    |----------|------------------------------|
    | `<C-i>`  | 跳到下一个缓冲区             |
    | `<C-o>`  | 跳到上一个缓冲区             |
    | :jumps   | 打印跳转列表                 |

    - 注意, `<C-i>` 和 `<C-o>`命令本身不会被当作动作命令, 既不能用它扩大可视选区的范围, 也不能在操作待决模式中使用它们. 

    - 映射时需要注意, 在插入模式下 vim 把 `<C-i>` 和 `<Tab>` 键看为是一个东西, 如果重新映射 `<Tab>` 键, 那么也应该意识到当按下 `<C-i>` 时, 该映射也会触发.

---

- #### 文件中的跳转命令
 
    | 动作     | 作用                         |
    |----------|------------------------------|
    | [range]G | 光标跳转到某行开头           |
    | %        | 光标跳转到括号上             |
    | (        | 光标跳转到上一句的开头       |
    | )        | 光标跳转到下一句的开头       |
    | {        | 光标跳转到上一段的开头       |
    | }        | 光标跳转到下一段开头         |
    | H        | 光标跳转到屏幕最上方         |
    | M        | 光标跳转到屏幕正中间         |
    | gf       | 打开光标下的路径             |
    | `<C-]>`  | 跳转到光标下关键字的定义之处 |
    | '{标记}  | 跳转到{标记}                 |
    | \`{标记} | 跳转到{标记}                 |
    | g;       | 跳转到上一次改变的位置       |
    | g,       | 反向跳转到上一次改变的位置   |

    - vim 会在编辑会话期间维护一张表, 里面记载了每个缓冲区所做的修改,此表就是所谓的改变列表.使用下面命令可以查看其内容.  
     
    ```vim
    :changes
    ```

    - vim 为每次修改都记录了行号和列号, 可以用 `g;` 和 `g,` 命令来反向或正向遍历改变列表.

    - vim 会自动创建一些位置标记, 它们是对改变列表的一个有用的补充, 详细见下表. (其中反引号也可以用单引号代替)

    | 标记 | 位置                           |
    |------|--------------------------------|
    | \`   | 当前文件上次跳转动作之前的位置 |
    | \`.  | 上次修改的地方                 |
    | \`^  | 上次插入的地方                 |
    | `[   | 上次修改或复制的起始位置       |
    | `]   | 上次修改或复制的结束位置       |
    | `<   | 上次高亮的起始位置             |
    | `>   | 上次高亮的结束位置             |

- #### 跳转到光标下的文件
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vim 会把文档中的文件名当成一个超链接, 正确配置后, 就可以用 `gf` 命令跳转到光标下的文件了
    
    - ##### 指定文件的扩展名  
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `suffixesadd` 选项运行指定一个或多个文件扩展名,当vim用 `gf` 命令搜寻文件名时, 会尝试使用这些扩展名. 用下面的命令可以设置此选项
    
    ```vim
    :set suffixesadd+=.py
    ```
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在如果用 `gf` 命令, vim 就会之间跳转到光标下的文件路径.每次用 `gf` 命令时, vim都会在跳转列表中增添一条记录, 因此总数可以用 `<C-o>` 命令返回原处.  
    
    - 指定要搜索的目录  
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果我们想引用第三库提供的功能时, 我们应该指定 `path` , 可以把它配置成一个以逗号分隔的目录列表, 当使用 `gf` 命令时, vim 会检查 `path` 目录列表中的每个目录, 看该目录中是否包含一个匹配光标下文本的文件名. `path` 设置也会用于 `:find` 命令.
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下面这条命令可以查看 `path` 选项的值.  
    
    ```vim
    :set path?
    ⇒ path=.,/usr/include,.
    ```
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在此设置中, `,.` 代表当前文件所在的目录, 空字符串则代表工作目录.
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于较大的工程来说, 我们可能需要想在 `path` 设置中包含更多的目录. 如果想要一种自动解决方案, 推荐使用 [bundler.vim](https://github.com/tpope/vim-bundler) 插件, 它会使用工程的 Gemfile 来自动生成 `path` 设置

    ---
    
- #### 全局位置标记
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 全局位置标记是一种书签, 让我们可以在文件间跳转, 全局标记在我们分析完代码, 并向快速跳回一个文件时非常有用.  
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `m{letter}` 命令运行在当前光标位置创建一个位置标记, 小写字母会创建局部于缓冲区的标记, 大写字母则创建全局标记. 设置好标记后, 就可以用 `{letter}` 命令快速使光标跳回到标记所在处.  
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 建议在浏览代码之前先设置一个全局标记, 假设我们正在编写代码, 而后向要查找代码中所有出现 **fooBar()** 函数的地方, 用 `:vimgrep` 命令可以完成这一查找.
    
    ```vim
    :vimgrep /fooBar/ **
    ```
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在默认情况下, `:vimgrep` 会直接跳转到它所找到的第一处匹配上, 这或许会切换到另一个文件. 在本例中, 可以使用 `<C-o>` 命令回到执行 `:vimgrep` 命令之前的位置.  
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 假设代码中有几十处匹配. 对于每个 `:vimgrep` 找到的匹配项, 在 `quickfix` 列表中都会为之创建一条记录. 现在假设我们花了一两分组时间遍历此列表, 最终找到了想找的内容. 现在又想回到执行 `:vimgrep` 命令之前的位置该怎么做呢?  
    
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以用 `<C-o>` 命令反向遍历跳转列表, 以返回该处, 但这估计得花不少时间. 这时全局标记就可以大显身手了. 如果在调用 `:vimgrep` 之前, 先执行了 `mM`, 那么此时用 `'M` 命令就能一下子迅速跳回原处.  

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一般来说要养成在使用于 `quickfix` 列表有关的命令前, 如 `:grep`, `:vimgrep`, `:make`, 设置全局标记的习惯. 另外在执行与缓冲区列表或参数列表有关命令前, 如 `:args{arglist}` 和 `:argdo`, 也要设置全局标记
