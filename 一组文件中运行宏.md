- #### 到目前为止 , 我们所关注的任务都是在相同的文件中用宏重复操作 , 但是也可以跨文件回放宏 . 这次仍然考虑如何以并行或者串行的方式执行宏

---
有这么两个函数
```python
#...注释
def well(name):
    print(f'它的名字是{name}')
    
def how(pagl):
    print(f'它会使用{pagl}')
    
```
把这2个 函数 封装为一个类,最终看起来是这样的
```python
#...注释
class Play:

    def well(self,name):
        print(f'它的名字是{name}')
    
    
    def how(self,pagl):
        print(f'它会使用{pagl}')
       
```
在执行宏之前先加载以下的配置
```vim
set nocompatible
filetype plugin indent on
set hidden
if has('autocmd')
    autocmd FileType ruby setlocal ts=2 sts=2 sw=2 expandtab
endif
```
打开目标文件
```vim
:cd 文件路径
:args *.py
```
这里使用不带参数的 ***:args*** 命令 ,就可以显示参数列表的内容 . 这样使用 **:first , :last , :prev , :next**就能遍历整个文件列表

录制宏

| 动作                          | 说明                                                                           |
| :-:                           | :-:                                                                            |
| :first                        | 跳转到参数列表中的第一个文件                                                   |
| qa                            | 开始录制宏                                                                     |
| gg/def< CR >                  | 跳到文件开头,由于每个文件开头有注释,<br>我们需要用查找命令找到我们要的 ***def*** |
| O< C-o > Oclass Play: < Esc > | 在def 的上方打2个空行,方便添加***class***                                        |
| j>G                           | 将class下面的行都缩进一行                                                      |
| /):< CR >biself,jnb.< Esc >   | 将每个函数添加上 ***self,*** <br>(这一步最好再单独另外录制一个宏来执行)          |
| q                             | 结束录制                                                                       |

---
- ### 以并行的方式运行宏
- ##### 如果正在使用编辑器,正在使用编辑器跟着做 , 请先别急着运行 ***:w*** 保存文件 , 因为这样只会保存当前窗口所在的缓冲区   
   
    - ##### ***:argdo*** 命令会运行对参数列表内的所有缓冲区执行一条Ex命令 ,但是现在如果执行 **:argdo** normal @a 命令的话将会出现副作用  
    
    - ##### 仔细想想便会发现 , 运行 ***:argdo noraml @a *** 将对所有参数列表的缓冲区执行刚录制的宏 , 当然也包括哪个在录制宏修改的文件 , 因此第一个缓冲区的内容会被封装两次
    
    - ##### 为了避免这种情况,将执行 ***:edit!*** 将放弃针对第一个缓冲区的所有修改(见:h edit!) 如果已经修改后已经保存至文件 ,那么执行 :edit! 将起不到任何作用 , 这种情况下只能执行 **u** 命令恢复到原样了
    
    - ##### 在恢复修改后 可以在参数列表中的所有缓冲区内执行宏了
    
    - ##### 尽管该技术需要进行一些设置 , 但它用一条命令就能为我们做很多工作 .
     
    - ##### 需要注意的是执行宏命令一定要注意是重复跳转是否会被中止 , 如果不会中止而使用过多次数的宏,则会出现我们不想要的结果
---
- ### 以串行的方式运行宏
- ##### 宏通常被用在单一的缓冲区执行单一的工作单元 , 如果想使其在多个缓冲区内运行 , 可以在宏的最后附加一个步骤 :  跳转到下一个缓冲区
- ##### 虽然可以执行 ***3@a*** 让宏在缓冲区列表余下的每个文件得以执行 , 但是次数没必要那么精确 , 因为 , 宏一旦执行到参数列表的最后一个缓冲区 , **:next** 命令将会失败 , 宏便会中止退出 ,所以,与其指定一个精确的数值,不如保证数字足够大就可以
---
- ### 保存所有文件的改动
- ##### 我们已经改了多个文件 , 但是一个也没有保存 , 运行 ***:argdo write*** 即可保存缓冲区列表的所有文件 , 但是如果 使用 **:wall ** 命令,会更快(该命令会保存缓冲区列表内的所有文件 , 因此它不完全等于 **:argdo write** 参见 h:wa)
- ##### 另一条有用的命令是 ***:wnext*** 它等同于先运行 ***:write*** 再执行 **:next** ,如果想用串行的方式 ,在参数列表的多个文件上执行宏,可能用这条命令会更好.
---
- ### 结论
- ##### 假设宏执行到位与参数的第三个缓冲区时,由于某种原因失败了 , 如果此使用并行的方式 ,则执行失败的缓冲区会受到影响 ; 不过如果以串行 , 带次数的方式执行宏 , 它将会中止执行 ,而参数列表余下的文件将不会被修改
- ##### 这一次我们在一组文件上运行 , 所以我们无法做到 '只需要看一眼就可以对所有情况了如指掌' 但是如果以串行的方式还好  一旦失败 , 便会在出错的位置停下来 但如果以并行的方式运行宏 , 一但失败 , 就不得不浏览整个参数列表.
- ##### 以并行的方式运行宏 , 虽然可能会更快的完成工作 , 不过当有错误发生时 , 会遗漏许多有用的信息
